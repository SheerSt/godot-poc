[gd_resource type="ShaderMaterial" load_steps=2 format=3 uid="uid://cr3j4k4iinj7o"]

[sub_resource type="Shader" id="2"]
code = "// credit to u/MartialArtTetherball
//https://www.reddit.com/r/godot/comments/gz2led/wrote_a_shader_that_maps_a_pixel_art_color/
//https://pastebin.com/bsdEUAgA

// NOTE: if put in a viewport container, light blending doeesn't happen and the palette is applied.
// Can palette the entire screen that way

shader_type canvas_item;
//render_mode light_only;  //blend_disabled, 
render_mode blend_disabled;

uniform vec3 bias = vec3(1.0, 0.25, 1.5); // Hue, Saturation (Saturation * Value), and Lightness (From LAB)

uniform sampler2D palette_texture;
varying flat float palette_size;
varying flat vec4 color_palette[24];


vec3 rgb2hsv(vec3 c) {
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

   float d = q.x - min(q.w, q.y);
   float e = 1.0e-10;
   return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

float rgb2lightness(vec3 c) { // adapted from lab color space equations
    vec3 tmp = vec3(
        (c.r>.04045)?pow((c.r+.055)/1.055,2.4):c.r/12.92,
        (c.g>.04045)?pow((c.g+.055)/1.055,2.4):c.g/12.92,
        (c.b>.04045)?pow((c.b+.055)/1.055,2.4):c.b/12.92
    );

    mat3 mat = mat3(
        vec3(0),
        vec3(0.2126,0.7152,0.0722),
        vec3(0)
    );

    vec3 xyz = 100.*(tmp*mat);
    vec3 n = xyz/vec3(95.047,100.,108.883),

    v = vec3(0, (n.y>.008856)?pow(n.y,1./3.):(7.787*n.y)+(16./116.), 0);
    return ((116.*v.y)-16.)/100.0;
}

void vertex() {
    palette_size = float(textureSize(palette_texture, 0).y);

    vec3 c;
    for (int i = 0; i < int(palette_size); ++i) {
        c = texelFetch(palette_texture, ivec2(0, i), 0).rgb;
        // pack colors from palette texture, and pre-calculate their lightnesses
        color_palette[i] = vec4(c, rgb2lightness(c));
    }
}

float square_magnitude(vec3 color) {
    return pow(color.x, 2) + pow(color.y, 2) + pow(color.z, 2);
}

float distance_with_hue_consideration(vec3 col_a, vec3 col_b) {
    float a = square_magnitude((col_a - col_b));
    float b = square_magnitude(((col_a - vec3(1.0, 0, 0)) - col_b));
    float c = square_magnitude(((col_a + vec3(1.0, 0, 0)) - col_b));

    a = min(a, b);
    return min(a, c);
}

float find_weighted_distance(vec4 color_a, vec3 color_b) {
    vec3 a_as_hsv = rgb2hsv(color_a.rgb);
    vec3 b_as_hsv = rgb2hsv(color_b);
    float a_lightness = color_a.a;
    float b_lightness = rgb2lightness(color_b);

    vec3 col1 = vec3(a_as_hsv.x, a_as_hsv.y * a_as_hsv.z, a_lightness);
    vec3 col2 = vec3(b_as_hsv.x, b_as_hsv.y * b_as_hsv.z, b_lightness);

    return distance_with_hue_consideration(
        col1 * bias,
        col2 * bias
    );
}

void fragment() {

    COLOR = texture(TEXTURE, UV);

    int index_of_closest;
    float distance_to_closest = 10000.0;
    vec3 c = COLOR.rgb;

    for (int i = 0; i < int(palette_size); i++) {
        float d = find_weighted_distance(color_palette[i], c);
        if (d < distance_to_closest) {
            index_of_closest = i;
            distance_to_closest = d;
        }
    }

    COLOR.rgb = color_palette[index_of_closest].rgb;
    
}

void light() {

    if (LIGHT_COLOR.a <= .6f) {  // This check is confirmed working.
        //LIGHT_COLOR = vec4(2f, 2f, 2f, 3f);
        //LIGHT_COLOR = vec4(COLOR.r * 2f, COLOR.g * 2f, COLOR.b * 2f, 3f);
        LIGHT_COLOR = vec4(3f, 3f, 3f, 3f);
        //MODULATE = vec4(1f, 1f, 1f, 1f);
        //LIGHT_HEIGHT = .000001f;
        //LIGHT_HEIGHT = 1000000f;
        LIGHT_VEC = vec2(0f, 0f);
        LIGHT = vec4(COLOR.r, COLOR.g, COLOR.b, 1f);
        //LIGHT = vec4(1f, 1f, 1f, 1f);
        //LIGHT = vec4(0f, 0f, 0f, 0f);
        //LIGHT_COLOR = vec4(1, 0, 0, 1);
    }
}

"

[resource]
shader = SubResource("2")
