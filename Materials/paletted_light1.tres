[gd_resource type="ShaderMaterial" load_steps=3 format=3 uid="uid://cr3j4k4iinj7o"]

[ext_resource type="Texture2D" uid="uid://cgm65g428v5dx" path="res://Tiles/tree1.palette.png" id="1_vnmrc"]

[sub_resource type="Shader" id="2"]
code = "// credit to u/MartialArtTetherball
//https://www.reddit.com/r/godot/comments/gz2led/wrote_a_shader_that_maps_a_pixel_art_color/
//https://pastebin.com/bsdEUAgA

// NOTE: if put in a viewport container, light blending doeesn't happen and the palette is applied.
// Can palette the entire screen that way


shader_type canvas_item;

//global uniform float light_angle;
uniform float light_angle = 45.0;
// TODO: MODULATE var is gone, so using this as shader param for now.
uniform vec3 modulate = vec3(1.0);
uniform vec3 ambient_light = vec3(1.0);
uniform vec3 light_color = vec3(1.0);

uniform vec3 bias = vec3(1.0, 0.5, 1.0); // Hue, Saturation (Saturation * Value), and Lightness (From LAB)

uniform sampler2D palette_texture;
varying flat float palette_size;
varying flat vec4 color_palette[24];


vec3 rgb2hsv(vec3 c) {
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

   float d = q.x - min(q.w, q.y);
   float e = 1.0e-10;
   return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

float rgb2lightness(vec3 c) { // adapted from lab color space equations
    vec3 tmp = vec3(
        (c.r>.04045)?pow((c.r+.055)/1.055,2.4):c.r/12.92,
        (c.g>.04045)?pow((c.g+.055)/1.055,2.4):c.g/12.92,
        (c.b>.04045)?pow((c.b+.055)/1.055,2.4):c.b/12.92
    );

    mat3 mat = mat3(
        vec3(0),
        vec3(0.2126,0.7152,0.0722),
        vec3(0)
    );

    vec3 xyz = 100.*(tmp*mat);
    vec3 n = xyz/vec3(95.047,100.,108.883),

    v = vec3(0, (n.y>.008856)?pow(n.y,1./3.):(7.787*n.y)+(16./116.), 0);
    return ((116.*v.y)-16.)/100.0;
}

float square_magnitude(vec3 color) {
    return pow(color.x, 2) + pow(color.y, 2) + pow(color.z, 2);
}

float distance_with_hue_consideration(vec3 col_a, vec3 col_b) {
    float a = square_magnitude((col_a - col_b));
    float b = square_magnitude(((col_a - vec3(1.0, 0, 0)) - col_b));
    float c = square_magnitude(((col_a + vec3(1.0, 0, 0)) - col_b));

    a = min(a, b);
    return min(a, c);
}

float find_weighted_distance(vec4 color_a, vec3 color_b) {
    vec3 a_as_hsv = rgb2hsv(color_a.rgb);
    vec3 b_as_hsv = rgb2hsv(color_b);
    float a_lightness = color_a.a;
    float b_lightness = rgb2lightness(color_b);

    vec3 col1 = vec3(a_as_hsv.x, a_as_hsv.y * a_as_hsv.z, a_lightness);
    vec3 col2 = vec3(b_as_hsv.x, b_as_hsv.y * b_as_hsv.z, b_lightness);

    return distance_with_hue_consideration(
        col1 * bias,
        col2 * bias 
    );
}

void vertex() {
    palette_size = float(textureSize(palette_texture, 0).y);

    vec3 c;
    for (int i = 0; i < int(palette_size); i++) {
        c = texelFetch(palette_texture, ivec2(0, i), 0).rgb;
        // pack colors from palette texture, and pre-calculate their lightnesses
        color_palette[i] = vec4(c, rgb2lightness(c));
		//color_palette[i] = vec4(c, 1.0);
    }
}

void fragment() {
    COLOR = texture(TEXTURE, UV);
	
	// Calculate basic output color after normal
	
	//vec3 norm = normalize(Normal);
	//vec3 lightDir = normalize(lightPos - FragPos);  
	//float diff = max(dot(norm, lightDir), 0.0);
	//vec3 diffuse = diff * lightColor;
	//vec3 result = (ambient + diffuse) * objectColor;
	//FragColor = vec4(result, 1.0);

	//vec3 lightDir = normalize(light_pos - vec3(UV, 0.0));
	vec3 lightDir = vec3(cos(light_angle), sin(light_angle), .8);
	float diff = max(dot(NORMAL, lightDir), 0.0);
	vec3 diffuse = diff * light_color;
	vec3 c = (ambient_light + diffuse) * COLOR.rgb;

    int index_of_closest;
    float distance_to_closest = 10000.0;

    for (int i = 0; i < int(palette_size); i++) {
        float d = find_weighted_distance(color_palette[i], c);
        if (d < distance_to_closest) {
            index_of_closest = i;
            distance_to_closest = d;
        }
    }

	//COLOR.rgb = c;
	
    COLOR.rgb = vec3(color_palette[index_of_closest].rgb) * modulate;
}
"

[resource]
shader = SubResource("2")
shader_parameter/ambient_light = null
shader_parameter/bias = Vector3(1, 0.5, 1)
shader_parameter/light_angle = 47.101
shader_parameter/light_color = null
shader_parameter/modulate = null
shader_parameter/palette_texture = ExtResource("1_vnmrc")
